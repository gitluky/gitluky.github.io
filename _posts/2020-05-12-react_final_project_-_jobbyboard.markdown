---
layout: post
title:      "React Final Project - Jobbyboard"
date:       2020-05-12 06:31:29 +0000
permalink:  react_final_project_-_jobbyboard
---


For my React/Rails project I created a web application where users can post help ads online. The scope of the project includes the following features:
1) User registration, authentication and authorization.
2) Users can view other user profiles, search posts and view posts without logging in.
3) In addition, users can create and manage posts, “like” posts, and write user reviews when logged in.
I began the project with confidence – it was a simple concept, nothing extremely different from the previous projects, boy was I wrong. I was practically moving all the logic I would normally place in my Rails view files into React components - bye bye Rails magic, I will miss you, <%form_for %>. Gone are the days that the instance variables in my Rails views, those lovely .erb files, are directly connected to my controller instance variables. This time I had to render serialized JSON data to my front-end, store that data into my Redux store and trickle down chunks of data to the children components that need them as props, and send API requests if I needed more data or wanted to persist something to the back-end. That was the project in a nutshell.

While working on this project, I’ve learned a great deal by venturing into the unknown, into topics that were not covered during the course and figured it was a good a time as any to introduce myself to them in order to further future-proof what I’ve learned so far. Some of these topics include authorization – specifically Token Based Authentication and React Hooks. There were other things that I quickly exposed myself to, such as, HTTPS/SSL, Material-UI, and uploading images to Rails ActiveStorage with React using the activestorage package. I will not be doing a deep-dive into all of these topics, it’s beyond the scope of this post, but I will write some follow up posts as a sort of documentation/cheatsheet to my future self and all who stumbles upon this blog. For now I will just highlight some questions/issues I had encountered and lessons learned.

In my previous projects, I’ve only relied on Rails to do the authorization for me, with it’s built-in Sessions feature, which authorizes users based on the sessions data stored in the database, cookies sent in the browser and Cross-Site Request Forgery(CSRF) tokens which Rails hides away into the views files and validated when sent back in a JSON request. Fortunately, while still early in development, I learned that most web applications that send requests to a backend api are using something called a JSON Web Token(JWT). Instead of maintaining a user session in the backend, JWTs allows it to be maintained in the front end. A JWT is simply an encoded string separating the following three parts with dots: header JSON object, payload(JSON object, usually a hash with user data) and a signature(generated by taking the encoded header and payload, and a secret key defined by the back-end, and running it through the algorithm specified in the header). When a user intially logs in to the application, a JWT is created and passed back to the user in the success request. The JWT is then passed back and forth in the header of API requests to verify the user.

When using JWTs, there are some things I had to consider:
1) A JWT is not stored in the database, so it can’t be revoked if it has been compromised.
2) In order to combat the first point, JWTs are usually created with a short expiration time, therefore if it has been stolen, it will expire before it can be used.
3) If the expiration time is so short, the user is logged out and is required to log in frequently.
4) Where do you store the JWT to keep it secure? I’ve read a lot of articles where developers will store it  in localstorage, which can be accessed by anyone who has access to the user’s browser. If you store it in a cookie, javascript will have access to it and make it vulnerable to XSS attacks.

What I ended up doing, which may or may not be the best solution is this:

1) In order to be able to revoke tokens, I created a column in my User table called jti. When a user logs off, or the JWT expires, a new jti is generated using SecureRandom.uuid. The jti is added as part of the payload in the JWT. When the JWT is sent back and decoded by the API, the jti in the token will be compared with the jti in the database to authorize the user. This allows me to revoke the JWT by simply changing the jti in the user row.
2) and 3) To prevent the user from being constantly signed out and requiring them to log back in every 5 minutes, I decided to copy OAuth’s approach of sending a refresh token along with the JWT. When the JWT expires, it validates the refresh token which will have much longer expiration duration than a JWT, and on success, will generate a new JWT and sign the user in behind the scenes. To hide the refresh token.
4) I had to configure Rails to be able to use cookies. When creating a Rails app with the –api flag, it creates a Rails app with the minimum modules required for an API, removing sessions and cookies functionality. After that, I essentially followed the same process of creating a JWT to create a refresh token, but instead of sending it back with the JWT in the login response header, I sent it back to the user in an HTTPOnly cookie, which javascript cannot access, making it safe from XSS attacks. The HTTPOnly cookie is included in all the fetch requests and validated when the JWT has expired.

The drawbacks of this approach is:
1)  One of the main purposes of using JWTs is so that you don’t have to store data in the backend, which I am definitely ignoring here.

Pros:
1) Being able to use JWTs a way that is less susceptible to XSS attacks.

I would like to say that it was a fun experience, but I still feel the damage of banging my head against the table trying to get cookies back into my Rails API, trying to get JWTs working with Devise, configuring CORS and cookies to be sent along with my API requests. It took me days until what seemed like a miracle where my stars aligned and it just started working. The bottom line is... unless you want to torture yourself as I did, it’s almost always a better idea to leave it to the pros and use a tried and true solution instead of rolling your own authentication/authorization solution.

Throughout this course, we’ve written all our React code using classes and functional components. There was a mention of React Hooks in one of the lessons which I mentally bookmarked but didn’t look into until I started working on this project. I hopped onto Youtube and pulled up the 1hr and 35min long video of the React Conference where it was first introduced. I watched it in awe and was immediately inspired – my mind’s internal dialogue echoed a conversation that could have easily been pulled straight out of the Mandalorian:
“This is the way.”
“Are you sure you want to get involved in all this? It looks complicated.”
“I have spoken!”

As a noob, I still don’t fully grasp all the benefits of using Hooks over Classes, I just wanted to try it out and as I said earlier “future-proof” my coding skills. It’s not like I uncovered all there is to know about the subject, I simply wrote all my components as functions and incorporated useState() and useEffect(). I liked that instead of juggling a bunch of lifecycle methods, I just had to toy around with useEffect(). I do prefer writing my components as functions and maintaining state this way over writing React Classes -  it seems simpler and more intuitive.
